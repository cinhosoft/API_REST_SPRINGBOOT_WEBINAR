{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Servicios Web REST sobre Spring Boot con Maven en NetBeans: 1. Configurar el Plugin de Spring Tools en NetBeans Se ingresa a Tools --> Plugins Se abrir\u00e1 la ventana de Plugins, damos click en la pesta\u00f1a Available Plugins y Buscamos NB SpringBoot 2. Crear el Proyecto Vamos a File New Project\u2026 Seleccionamos Java with Maven: Digitamos el Nombre de nuestro grupo de paquetes, el Artifact, el Empaquetado, la descripci\u00f3n, el lenguaje Java y la version: Agregamos las dependencias: Agregamos el nombre y ubicaci\u00f3n del proyecto: 3. Crear la base de datos Ingresar a su manejador de base de datos y ejecutar el comando, para crear la base de datos: CREATE DATABASE webinarunab; 4. Cargar Configuraci\u00f3n en el application.properties Una vez creado el proyecto, vamos al application.properties, donde vamos a indicar la cadena de conexi\u00f3n de MySQL, el puerto por el que va correr el API y los par\u00e1metros del hib\u00e9rnate, as\u00ed: server.port=9011 spring.datasource.url=jdbc:mysql://localhost:3306/webinarunab spring.datasource.username=root spring.datasource.password=******* ## Hibernate Properties # The SQL dialect makes Hibernate generate better SQL for the chosen database spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect # Hibernate ddl auto (create, create-drop, validate, update) spring.jpa.hibernate.ddl-auto = create Nota: Modificar los datos correspondientes seg\u00fan la configuraci\u00f3n de servidor de mysql, cambiando el nombre de la base de datos, si la crearon diferente, cambiando el username por su usuario y los asteriscos * por la password del usuario del MySQL. 5. Crear Los Paquetes El siguiente paso es crear los paquetes debajo del paquete principal donde se encuentra la clase @SpringBootApplication, la estructura debe quedar de la siguiente manera: Para crear un paquete se debe dar click derecho sobre el paquete principal, luego New--> Java Package\u2026 Creamos el Paquete Models: Creamos el Paquete Repositories : Creamos el Paquete Services: Creamos el SubPaquete Impls: Este es el subpaquete que implementa las interfaces de nuestro paquete services, por lo cual se debe crear debajo de services, dando click derecho sobre service --> new --> Java Package\u2026 Creamos el Paquete Controllers: 6. Creamos Las Clases de Models Paso 1: Estas clases ser\u00e1n nuestras Entity, por lo cual las debemos crear dando click derecho sobre el paquete Models, new --> Java Class\u2026 Digitamos el nombre de la clase: Paso 2: Una vez creada la Clase Le Agregamos la Anotaci\u00f3n @Entity, adicionalmente es una buena practica que las clases del Models implementen la interface Serealizable, eso lo agregamos en la declaraci\u00f3n de la clase con implements Serializable: Nota: Importante cuando estemos agregando las anotaciones importar las respectivas clases necesarias, las de persistencia se importan de javax.persistence.Table: Si estamos trabajando con un IDE o un editor de c\u00f3digo con un buen plugin, cuando agreguemos las anotaciones @Entity y @Table, nos va a proponer que implementemos el comportamiento de la interfaz se realizable: Paso 3: Luego declaramos los campos de la entidad y debe quedar as\u00ed: Crear Clase Factura: Repetimos los pasos 1, 2 y 3 del punto 6, para que nos quede una clase Factura As\u00ed: Una vez tenemos las clases de esta manera vamos a dar un vistazo al modelo entidad relaci\u00f3n donde se especifican las relaciones, este es un ejercicio b\u00e1sico con 3 tablas de las cuales vamos a desarrollar dos: Nota: los ides fueron modificados para simular en el programa de dise\u00f1o el nombre con que SpringBoot Crea las relaciones for\u00e1neas, pero en la clase el id de cada entidad, ser\u00e1 nombrado como \u201cid\u201d autoincrementadle. En este punto vamos a editar el archivo POM.xml para agregar una dependencia de validaci\u00f3n: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> Revisamos las condiciones de la entidad Cliente: Con este planteamiento debemos agregar las respectivas anotaciones a cada campo seg\u00fan los detalles de cada uno: Al id le agregamos la anotaci\u00f3n @Id para identificarla como llave primaria de la entidad y el @GeneratedValue(strategy = GenerationType.IDENTITY) para que este sea autoincrementable. Al nombre le agregamos la anotaci\u00f3n @NotEmpty(message = \"no puede estar vacio\") con un mensaje, indicando que este no puede ser vacio, el @Size(min = 4, max = 12, message = \"el tama\u00f1o tiene que estar entre 4 y 12\") para especificar el tama\u00f1o m\u00ednimo y m\u00e1ximo del nombre, con el respectivo mensaje informativo y el @Column(nullable = false, length=30)) indicado que este campo es NOT NULL y largo de 30. Al apellido le agregamos @NotEmpty(message = \"no puede estar vacio\") y @Column(nullable = false, length=30). Al mail le agregamos @NotEmpty(message = \"no puede estar vacio\"), la validacion @Email(message = \"no es una direcci\u00f3n de correo bien formada\") y @Column(nullable = false, unique = true) NOT NULL y que no se pueda repetir. A la fechaCreacion le agregamos el @Column(name = \"fecha_creacion\") le ponemos un nombre y @Temporal(TemporalType.DATE) para que lo interprete como tipo DATE. En aras de optimizar el API, vamos a agregar una vinculaci\u00f3n de la relaci\u00f3n de uno a muchos que tiene con la Entidad Factura, esto con el objetivo de que en el momento de hacer un llamado al cliente, no regrese las facturas que tiene dicho cliente, para eso vamos a crear otro campo de tipo Lista que retorna facturas; List y le vamos agregar las anotaciones @JsonIgnoreProperties(value={\"cliente\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) para que hibernate no lo cree como campo de la tabla, @OneToMany(fetch = FetchType.LAZY, mappedBy = \"cliente\", cascade = CascadeType.ALL) indicando la relaci\u00f3n de uno a muchos la cual se ejecutara en modo Lazy, para que se cargue cuando se necesiten, mapeado por el cliente, que es el campo declarado en la tabla factura como llave for\u00e1nea y la propiedad cascade, para que respete la jerarqu\u00eda seg\u00fan las relaciones de la tabla, es decir si deseamos borrar un cliente, en cascada se borraran las facturas. Luego insertamos el constructor, \u00fanicamente carg\u00e1ndole el campo facturas que son las que ser\u00e1n variables: Paso 1: Click derecho Insert Code\u2026 Paso 2: Click en Constructor: Paso 3: Click en facturas y luego Generate: Despu\u00e9s, click derecho insert code --> Getter and Setter y seleccionamos todo: Finalmente agregaremos un m\u00e9todo con la anotaci\u00f3n @PrePersist para asignar la fecha de creaci\u00f3n de cliente antes de guardar, es un m\u00e9todo de preguardado. @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } La Clase Cliente, queda as\u00ed: import com.fasterxml.jackson.annotation.JsonIgnoreProperties; import java.io.Serializable; import java.util.ArrayList; import java.util.Date; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToMany; import javax.persistence.PrePersist; import javax.persistence.Table; import javax.persistence.Temporal; import javax.persistence.TemporalType; import javax.validation.constraints.Email; import javax.validation.constraints.NotEmpty; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; @Entity @Table(name = \"cliente\") public class Cliente implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty(message = \"no puede estar vacio\") @Size(min = 4, max = 12, message = \"el tama\u00f1o tiene que estar entre 4 y 12\") @Column(nullable = false, length = 30) private String nombre; @NotEmpty(message = \"no puede estar vacio\") @Column(nullable = false, length = 30) private String apellido; @NotEmpty(message = \"no puede estar vacio\") @Email(message = \"no es una direcci\u00f3n de correo bien formada\") @Column(nullable = false, unique = true) private String email; //@NotNull(message = \"no puede estar vacio\") @Column(name = \"fecha_creacion\") @Temporal(TemporalType.DATE) private Date fechaCreacion; @JsonIgnoreProperties(value = {\"cliente\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters = true) @OneToMany(fetch = FetchType.LAZY, mappedBy = \"cliente\", cascade = CascadeType.ALL) private List<Factura> facturas; @PrePersist public void prePersist() { System.out.println(\"Preguardado\"); this.fechaCreacion = new Date(); } public Cliente() { this.facturas = new ArrayList<>(); } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getFechaCreacion() { return fechaCreacion; } public void setFechaCreacion(Date fechaCreacion) { this.fechaCreacion = fechaCreacion; } public List<Factura> getFacturas() { return facturas; } public void setFacturas(List<Factura> facturas) { this.facturas = facturas; } } Revisamos las condiciones de la entidad Factura: Con este planteamiento debemos agregar las respectivas anotaciones a cada campo seg\u00fan los detalles de cada uno: Al Id @Id y @GeneratedValue(strategy = GenerationType.IDENTITY), llave primaria y autoincrementadle. A la descripci\u00f3n @Column(nullable = false, length=200). A la observaci\u00f3n @Column(nullable = false, length=500) A la fechaCreacion el @Column(name = \"fecha_creacion\") y @Temporal(TemporalType.DATE) Al cliente @JsonIgnoreProperties(value={\"factura\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) y @ManyToOne(fetch = FetchType.LAZY) el JsonIgnore y la relaci\u00f3n de mucho a uno, aqu\u00ed no es necesario especificarle el nombre del campo en la tabla, por que por defecto SpringBoot lo crea siguiendo, la l\u00f3gica del nombre de la clase seguido de raya al piso id as\u00ed: cliente_id. Finalmente agregaremos un m\u00e9todo con la anotaci\u00f3n @PrePersist para asignar la fecha de creaci\u00f3n de cliente antes de guardar, es un m\u00e9todo de preguardado. @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } Agregamos Los Getter y Setter, luego la Clase Factura Quedar\u00eda As\u00ed: @Entity @Table(name=\"factura\") public class Factura implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length=200) private String descripcion; @Column(nullable = false, length=500) private String observacion; @Column(name = \"fecha\\_creacion\") @Temporal(TemporalType.DATE) private Date fechaCreacion; @JsonIgnoreProperties(value={\"factura\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) @ManyToOne(fetch = FetchType.LAZY) private Cliente cliente; @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getObservacion() { return observacion; } public void setObservacion(String observacion) { this.observacion = observacion; } public Date getFechaCreacion() { return fechaCreacion; } public void setFechaCreacion(Date fechaCreacion) { this.fechaCreacion = fechaCreacion; } public Cliente getCliente() { return cliente; } public void setCliente(Cliente cliente) { this.cliente = cliente; } } 7. Creamos Las Interfaces del Repositories: Si estamos utilizando un buen plugin este proceso es sencillo, si lo que queremos es utilizar el repositorio solo para un crud, siguiendo los siguientes pasos, de igual manera si lo vamos hacer a mano creando la interface y heredando de la clase CrudRepository o JpaRepository seg\u00fan lo que se desee, la diferencia entre los dos es que Jpa incluye mas anotaciones para personalizar nuestro repositorio. Vamos a dar click derecho sobre el paquete respositories --> New --> Repository Interface Digitamos el nombre ClienteRepository, La interface base, le Entidad y el Tipo de dato del Id de la Clase Entidad: Nota: si no encontramos entre los primeros se debe buscar en Other as\u00ed, en la categor\u00eda Spring Framework estan las Clases e Interfaces, que podr\u00e1n creadas con un ayuda del plugin: Quedar\u00e1 as\u00ed: Una vez Creada debemos importar la clase entidad, para corregir el error que vemos en la imagen. La clase ClienteRepository quedar\u00eda as\u00ed: package com.example.webinaUnab.repositories; import com.example.webinaUnab.models.Cliente; import org.springframework.data.jpa.repository.JpaRepository; /** * * @author Marlon */ public interface ClienteRepository extends JpaRepository<Cliente, Long> { } Repetimos el proceso para agregar la clase FacturaRepository: ![](Aspose.Words.1885f979-9e30-4ff3-91e0-fd4ffca79d3f.032.png) la cual quedar\u00eda as\u00ed: package com.example.webinaUnab.repositories; import com.example.webinaUnab.models.Factura; import org.springframework.data.jpa.repository.JpaRepository; /\\\\** \\** \\ @author Marlon \\/ public interface FacturaRepository extends JpaRepository<Factura, Long> { \\ } 8. Creamos las Interfaces de los Services Se crea una nueva interface, pero ojo es importante que este se cree sobe el paquete service, teniendo en cuenta que al crear el paquete service y el subpaquete impls, queda todo el subpaquete asi: Con lo cual en el momento de crear la interface se debe modificar dejando claro que esa interface se va crear sobre el paquete services, especificando el siguiente par\u00e1metro en el package: com.example.webinaUnab.services. Adicionalmente es una buena practica al momento de nombrarlo agregarle la inicial \u201cI\u201d que la identifica como Interface, luego el nombre de la Entidad y El apellido serie el Paquete Service quedando IClienteService y IFacturaService: Creamos la interface y agregamos las funciones y m\u00e9todos: findAll retorna una lista de objetos Cliente: public List findAll(); findAll retorna un objeto Page con Cliente: public Page findAll(Pageable pageable); findById recibe como par\u00e1metro el id y retorna un Cliente: public Cliente findById(Long id); save, recibe un Cliente y retorna un Cliente: public Cliente save(Cliente cliente); delete, recibe el id para borrar el Cliente: public void delete(Long id); Esos son los m\u00e9todos b\u00e1sicos para hacer un CRUD, la interface IClienteService quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import java.util.List; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; /** * * @author Marlon */ public interface IClienteService { public List<Cliente> findAll(); public Page<Cliente> findAll(Pageable pageable); public Cliente findById(Long id); public Cliente save(Cliente cliente); public void delete(Long id); } Repetimos los mismos pasos para crear todas las interfaces, para continuar con lo que venimos desarrollando, la Interface IFacturaService quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Factura; import java.util.List; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; /** * * @author Marlon */ public interface IFacturaService { public List<Factura> findAll(); public Page<Factura> findAll(Pageable pageable); public Factura findById(Long id); public Factura save(Factura factura); public void delete(Long id); } 9. Implementamos las Interfaces de los Services El plugin de NetBeans tambi\u00e9n nos ayuda en la creaci\u00f3n de una clase service, pero si se decide hacer a mano es solo crear una nueva clase y agregarle la anotaci\u00f3n @service: Paso 1: Crear La Clase Asignamos el nombre ClienteServiceImpl y click en Finish: Paso 2: Declaramos que esta interface implementa los metodos de IClienteService con: implements IClienteService Luego importamos IClienteService y nos pedir\u00e1 que implementemos los m\u00e9todos de la interface: Paso 3: Una vez se implementan los m\u00e9todos estos se crean con una interrupci\u00f3n como c\u00f3digo, la cual debemos borrar y codificar las verdaderas funciones de cada m\u00e9todo: Paso 4: Pero antes de esto vamos a inyectar con la anotaci\u00f3n @Autowired una variable te tipo del Repositorio correspondiente a Cliente, la cual es ClienteRepository @Autowired private ClienteRepository clienteRepository; Paso 5: En este paso vamos a codificar los m\u00e9todos, sobre el nombre de cada m\u00e9todo vamos agregar la anotaci\u00f3n @Transactional(readOnly = true) para identificar que es un m\u00e9todo de tipo transaccional, luego quitamos la interrupci\u00f3n throw. Es importante cuando importemos la clase revisar que lo importemos de springbootframework para evitar errore: Funci\u00f3n findAll: esta funci\u00f3n retorna una lista de tipo Cliente, la cual la obtenemos invocando el m\u00e9todo findAll heredado de JpaRepository para la Entidad Cliente, usando la variable del repositorio clienteRepository.findAll(), el return quedar\u00eda as\u00ed: return (List ) clienteRepository.findAll(); Funci\u00f3n findAll(Pageable pageable): esta funci\u00f3n retorna una lista paginada de clientes, la cual obtenemos llamando el m\u00e9todo findAll(Pageable pageable) que recibe un objeto pageable, el return quedar\u00eda as\u00ed: return clienteRepository.findAll(pageable); Funci\u00f3n findById: esta funci\u00f3n recibe el id de un Cliente los busca y lo retorna, con lo cual el return se hace mediante el m\u00e9todo findById(id) que recibe un id y con la ayuda del submetodo orElse(null) retorna null si no lo encuentra, el return quedar\u00eda as\u00ed: return clienteRepository.findById(id).orElse(null); Funci\u00f3n save: esta funci\u00f3n recibe un objeto de tipo Cliente y con la ayuda del clienteRepository, invoca el m\u00e9todo save(cliente) que recibe el objeto Cliente y lo guarda en la tabla cliente, luego lo retorna, el c\u00f3digo quedar\u00eda as\u00ed: return clienteRepository.save(cliente); Metodo delete: este m\u00e9todo recibe un id de tipo long y mediante el clienteRepository, invoca el m\u00e9todo delete(id) que esta dise\u00f1ado por JpaRepository para eliminar un objeto de la tabla cliente cuando este coincida con el id recibido, el c\u00f3digo quedar\u00eda asi: clienteRepository.deleteById(id); La Clase ClienteServiceImpl quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import com.example.webinaUnab.repositories.ClienteRepository; import com.example.webinaUnab.services.IClienteService; import java.awt.print.Pageable; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; /** * * @author Marlon */ @Service public class ClienteServiceImpl implements IClienteService { @Autowired private ClienteRepository clienteRepository; @Override @Transactional(readOnly = true) public List<Cliente> findAll() { return (List<Cliente>) clienteRepository.findAll(); } @Override @Transactional(readOnly = true) public Page<Cliente> findAll(org.springframework.data.domain.Pageable pageable) { return clienteRepository.findAll(pageable); } @Override @Transactional(readOnly = true) public Cliente findById(Long id) { return clienteRepository.findById(id).orElse(null); } @Override public Cliente save(Cliente cliente) { return clienteRepository.save(cliente); } @Override public void delete(Long id) { clienteRepository.deleteById(id); } } Repetimos los paso 1, 2, 3, 4 y 5 con las dem\u00e1s servicios y los implementamos seg\u00fan las interfaces creadas, para seguir con el proyecto como lo llevamos la clase FacturaServiceImpl quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Factura; import com.example.webinaUnab.repositories.FacturaRepository; import com.example.webinaUnab.services.IFacturaService; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; /** * * @author Marlon */ @Service public class FacuraServiceImpl implements IFacturaService { @Autowired private FacturaRepository facturaRepository; @Override @Transactional(readOnly = true) public List<Factura> findAll() { return (List<Factura>) facturaRepository.findAll(); } @Override @Transactional(readOnly = true) public Page<Factura> findAll(Pageable pageable) { return facturaRepository.findAll(pageable); } @Override @Transactional(readOnly = true) public Factura findById(Long id) { return facturaRepository.findById(id).orElse(null); } @Override public Factura save(Factura factura) { return facturaRepository.save(factura); } @Override public void delete(Long id) { facturaRepository.deleteById(id); } } 10. Crear los Controllers El ultimo paso para verificar el funcionamiento de nuestra API, donde se van a configurar las rutas URI y los M\u00e9todos Utilizados en el APIREST se deben crear los controladores uno por cada servicio implementado, el plugin de NetBeans nos ayuda a crearlos, pero tambi\u00e9n se puede crear a mano agregando la anotaci\u00f3n @RestController. Paso 1: Damos Click derecho sobre el paquete controllers-->new-->RestController Class\u2026 El plugin nos ayuda a crear los m\u00e9todos para el CRUD y validar los errores HTTP, si deseamos que sean generados autom\u00e1ticamente debemos chequear Generate CRUD methods: Esto crea autom\u00e1ticamente un controlador con rutas URI por defecto y c\u00f3digos M\u00e9todos que retornan ResponseEntity para el manejo de c\u00f3digos de estado HTTP, en los m\u00e9todos del CRUD, adicionalmente nos genera los m\u00e9todos de comunicaci\u00f3n de la API, GET, PUT, POST, DELETE: Paso 2: Procedemos a editar la URI y a codificar cada uno de los m\u00e9todos los cuales por defecto cuando se crean autom\u00e1ticamente retornan null, es decir hay que codificarle los m\u00e9todos de los servicios. Una vez editemos el m\u00e9todo del encabezado vamos a agregar la anotaci\u00f3n @CrossOrigin(origins = { \"http://localhost:4200\", \"*\" }) donde podemos indicarle desde que URL se va consumir la API, en este ejemplo agregamos localhost:4200 y \\ este ultimo permite peticiones de cualquiera, esto es lo que se conoce como validaci\u00f3n de CORS(Intercambio de Or\u00edgenes Cruzado). Cross-origin resource sharing es lo que nos da el acceso a los recursos esta anotaci\u00f3n puede ser personalizada por cada m\u00e9todo o se puede agregar a todo el controlador. Paso 3: Procedemos a inyectar la variable del servicio con la anotaci\u00f3n @Autowired, podemos inyectar la interface, java toma por defecto la clase que implementa los m\u00e9todos de la interface, quedando as\u00ed: @Autowired private IClienteService clienteService; Paso 4: Codificar Funciones y M\u00e9todos del Controlador. Funci\u00f3n list: Retorna una lista de objetos Cliente, la codificaci\u00f3n quedar\u00eda as\u00ed, invocando el medido findAll() del servicio: @GetMapping() public List<Cliente> list() { **return clienteService.findAll();** } Funci\u00f3n index: Esta funci\u00f3n retorna un objeto Page de tipo cliente, que recibe un valor integer con el numero de pagina que se desea retornar, el c\u00f3digo quedar\u00eda as\u00ed: @GetMapping(\"/clientes/page/{page}\") public Page<Cliente> index(@PathVariable Integer page) { Pageable pageable = PageRequest.of(page,4); return clienteService.findAll(pageable); } Funci\u00f3n get: Esta funci\u00f3n recibe un par\u00e1metro id y retorna un Objeto Cliente en formato Json, con lo cual para personalizar la respuesta en caso que no exista, se creo adem\u00e1s del objeto Cliente, un Mapa que contiene una respuesta, con un mensaje de error, esta funcion tambien retorna adem\u00e1s de la respuesta un c\u00f3digo de estado HTTP, quedando as\u00ed: @GetMapping(\"/{id}\") public ResponseEntity<?> get(@PathVariable Long id) { Cliente cliente = null; Map<String, Object> response = new HashMap<>(); try { cliente = clienteService.findById(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar la consulta en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } if (cliente == null) { response.put(\"mensaje\", \"El cliente ID: \".concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT\\_FOUND); } return new ResponseEntity<Cliente>(cliente, HttpStatus.OK); } Funci\u00f3n put: esta funci\u00f3n retorna un c\u00f3digo de estado HTTP, esta validado con la anotaci\u00f3n @Valid y recibe del @RequestBody un cliente con los nuevos datos, BindingResult result para la validaci\u00f3n de la dependencia validator y @PathVariable Long id con el identificador del cliente que se va actualizar. Lo siguiente es buscar el cliente que se va actualizar: Cliente clienteActual = clienteService.findById(id); Declaramos una variable de tipo Cliente donde se va cargar los datos del cliente actualizado: Cliente clienteUpdated = null; Declaramos un mapa para manejar la respuesta: Map response = new HashMap<>(); Si el validador saca error responderemos con los parametros de respuesta que le agregamos a la validaci\u00f3n, los cuales cargamos en una lista de tipo String de nombre errors, cargamos la lista al mapa response.put(\u201cerrors\u201d, errors) y retornamos el mapa con el c\u00f3digo HTTP Bad Request: if (result.hasErrors()) List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); Luego si el cliente es nulo retornamos el mapa con un mensaje indicando que no existe en la base de datos: response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD\\_REQUEST); } Si todo esta correcto actualizamos el cliente, carg\u00e1ndolo al mapa y lo retornamos como respuesta con el c\u00f3digo Created: try { clienteActual.setApellido(cliente.getApellido()); clienteActual.setNombre(cliente.getNombre()); clienteActual.setEmail(cliente.getEmail()); clienteActual.setFechaCreacion(cliente.getFechaCreacion()); clienteUpdated = clienteService.save(clienteActual); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al actualizar el cliente en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente ha sido actualizado con \u00e9xito!\"); response.put(\"cliente\", clienteUpdated); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); Funci\u00f3n create: Este m\u00e9todo esta validado con el @Valid y recibe mediante el @RequestBody un objeto Cliente cliente y BindingResult result para validar. Declaramos la variable Cliente que vamos a retornar: Cliente clienteNew = null; Declaramos tambi\u00e9n el mapa para la respuesta personalizada: Map response = new HashMap<>(); Validamos si hay errores, los capturamos en una lista y los cargamos al mapa para responder con un c\u00f3digo Bad Request: if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD\\_REQUEST); } Si todo es correcto ejecutamos el m\u00e9todo sabe, si por alg\u00fan motivo el m\u00e9todo sabe falla, se captura la excepci\u00f3n y se retorna un HTTP de error interno del servidor, si no hay excepciones se carga el mapa de respuesta que incluye el objeto cliente que esta en la variable clienteNew: try { clienteNew = clienteService.save(cliente); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar el insert en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente ha sido creado con \u00e9xito!\"); response.put(\"cliente\", clienteNew); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); Funci\u00f3n Delete: esta funci\u00f3n recibe como par\u00e1metro el id del cliente, el cual se va enviar en el delete, tambi\u00e9n declaramos un mapa para la respuesta: Map<String, Object> response = new HashMap<>(); try { clienteService.delete(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al eliminar el cliente de la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente eliminado con \u00e9xito!\"); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); El c\u00f3digo completo del controlador ClienteController quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import com.example.webinaUnab.services.IClienteService; import java.util.HashMap; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; import java.util.Map; import java.util.stream.Collectors; import javax.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.dao.DataAccessException; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.http.HttpStatus; import org.springframework.validation.BindingResult; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseStatus; /** * * @author Marlon */ @CrossOrigin(origins = {\"http://localhost:4200\", \"*\"}) @RestController @RequestMapping(\"/cliente\") public class ClienteRestController { @Autowired private IClienteService clienteService; @GetMapping() public List<Cliente> list() { return clienteService.findAll(); } @GetMapping(\"/clientes/page/{page}\") @ResponseStatus(HttpStatus.OK) public Page<Cliente> index(@PathVariable Integer page) { Pageable pageable = PageRequest.of(page, 4); return clienteService.findAll(pageable); } @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public ResponseEntity<?> get(@PathVariable Long id) { Cliente cliente = null; Map<String, Object> response = new HashMap<>(); try { cliente = clienteService.findById(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar la consulta en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } if (cliente == null) { response.put(\"mensaje\", \"El cliente ID: \".concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); } return new ResponseEntity<Cliente>(cliente, HttpStatus.OK); } @PutMapping(\"/{id}\") public ResponseEntity<?> put(@Valid @RequestBody Cliente cliente, BindingResult result, @PathVariable Long id) { Cliente clienteActual = clienteService.findById(id); Cliente clienteUpdated = null; Map<String, Object> response = new HashMap<>(); if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST); } if (clienteActual == null) { response.put(\"mensaje\", \"Error: no se pudo editar, el cliente ID: \" .concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); } try { clienteActual.setApellido(cliente.getApellido()); clienteActual.setNombre(cliente.getNombre()); clienteActual.setEmail(cliente.getEmail()); clienteActual.setFechaCreacion(cliente.getFechaCreacion()); clienteUpdated = clienteService.save(clienteActual); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al actualizar el cliente en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente ha sido actualizado con \u00e9xito!\"); response.put(\"cliente\", clienteUpdated); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); } @PostMapping public ResponseEntity<?> create(@Valid @RequestBody Cliente cliente, BindingResult result) { Cliente clienteNew = null; Map<String, Object> response = new HashMap<>(); System.out.println(cliente.getApellido()); if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST); } try { clienteNew = clienteService.save(cliente); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar el insert en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente ha sido creado con \u00e9xito!\"); response.put(\"cliente\", clienteNew); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); } @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { Map<String, Object> response = new HashMap<>(); try { //Cliente cliente = clienteService.findById(id); clienteService.delete(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al eliminar el cliente de la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente eliminado con \u00e9xito!\"); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); } } Repetimos el paso 1,2,3 y 4 para crear el controlador de la entidad Factura, FacturaController, en el controlador anterior creamos un controlador completo con respuesta personalizada, lo cual hace que nuestra API, nos entregue respuestas mas claras, pero si quisi\u00e9ramos hacer un CRUD muy b\u00e1sico podemos hacerlo sin la necesidad de validar, esto no es recomendable porque nos exponemos a muchos errores que no entenderemos en el FrontEnd, pero para este ejercicio acad\u00e9mico vamos a crear este segundo controlador b\u00e1sico sin validaciones. Repetimos el paso 1, creamos el Rest Controller, le asignamos el nombre y chequemos el Generate CRUD methods: No genera la estructura b\u00e1sica de los m\u00e9todos la cual vamos a modificar seg\u00fan la necesidad: Lo primero es agregar con @Autowired la variable del servicio que vamos a inyectar directamente al controlador. @Autowired private IFacturaService facturaService; Funci\u00f3n List: este m\u00e9todo lista todas las facturas registradas, le agregamos la anotaci\u00f3n @ResponseStatus(HttpStatus.OK) para que por defecto responda c\u00f3digo 200 y con return facturaService.findAll(); liste las facturas, el metodo completo quedar\u00eda asi: @GetMapping() @ResponseStatus(HttpStatus.OK) public List<Factura> list() { return facturaService.findAll(); } Funci\u00f3n get: esta recibe el id de la factura y retorna una factura, tambi\u00e9n agregamos la anotaci\u00f3n @ResponseStatus(HttpStatus.OK) y con facturaService.findById(id) retornamos la factura buscada, es importante cuando se crean autom\u00e1ticamente los m\u00e9todos del controlador, reemplazar el Object que le agrega por defecto a los m\u00e9todos por la clase correspondiente en este caso seria Factura, la funci\u00f3n completa queda as\u00ed: @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public Factura get(@PathVariable Long id) { return facturaService.findById(id); } Funci\u00f3n create: esta es la que se encarga de crear la factura en la base de datos, recibe un objeto de tipo factura la cual vamos a guardar, para agregar una validaci\u00f3n b\u00e1sica agregamos un try catch, en el try ejecutamos la funci\u00f3n save y retornamos la factura con c\u00f3digo HTTP 200, en caso de alg\u00fan error pasar\u00eda por la excepci\u00f3n que retorna un error NotFound. @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity<?> create(@RequestBody Factura factura) { try{ return ResponseEntity.status(HttpStatus.CREATED) .body(facturaService.save(factura)); } catch (Exception e) { return ResponseEntity.notFound().build(); } Funci\u00f3n delete: Esta funci\u00f3n recibe el id de la factura y con la funci\u00f3n delete la borra de la base de datos, igual que en el save vamos agregar un try para controlar los errores en caso que el m\u00e9todo delete falle nos responda NotFoun, en caso que elimine la factura responder\u00eda el c\u00f3digo 204, el m\u00e9todo completo quedar\u00eda as\u00ed: @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { try { facturaService.delete(id); return ResponseEntity.noContent().build(); } catch (Exception e) { return ResponseEntity.notFound().build(); } } Funci\u00f3n put: este es el m\u00e9todo mediante el cual vamos actualizar los datos de la factura incluso si se desea cambiar el cliente, recibimos mediante el @RequesBody la factura con los datos en Json y por el @PathVariable el id de la factura que se va a modificar, lo siguiente que se hace es buscar la factura, porque si el id que nos pasan no existe, no se podr\u00e1 hacer la actualizaci\u00f3n, si no existe el API responde Not Found, pero si existe validamos que vengan los campos necesarios para actualizar, en la parte del cliente ocurre algo importante, si viene el objeto cliente dentro del json del cual podremos actualizar el id, buscamos el cliente y lo actualizamos. @PutMapping(\"/{id}\") public ResponseEntity<?> put(@RequestBody Factura factura, @PathVariable(value = \"id\") Long id) { Factura facturaEncontrada = facturaService.findById(id); if (facturaEncontrada == null) { return ResponseEntity.notFound().build(); } if (factura.getDescripcion() != null) { facturaEncontrada.setDescripcion(factura.getDescripcion()); } if (factura.getObservacion() != null) { facturaEncontrada.setObservacion(factura.getObservacion()); } if (factura.getFechaCreacion() != null) { facturaEncontrada.setFechaCreacion(factura.getFechaCreacion()); } //si se requiere cambiar de cliente la factura if (factura.getCliente() != null) { Cliente cliente = clienteService.findById(factura.getCliente().getId()); if (cliente != null) { facturaEncontrada.setCliente(cliente); } } return ResponseEntity.status(HttpStatus.CREATED).body(facturaService.save(facturaEncontrada)); } El Controlador FacturaController completo queda as\u00ed: /** * * @author Marlon */ @RestController @CrossOrigin(origins = \"/*\") @RequestMapping(\"/factura\") public class FacturaRestController { @Autowired private IFacturaService facturaService; @Autowired private IClienteService clienteService; @GetMapping() @ResponseStatus(HttpStatus.OK) public List<Factura> list() { return facturaService.findAll(); } @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public Factura get(@PathVariable Long id) { return facturaService.findById(id); } //actualizar @PutMapping(\"/{id}\") public ResponseEntity<?> put(@RequestBody Factura factura, @PathVariable(value = \"id\") Long id) { Factura facturaEncontrada = facturaService.findById(id); if (facturaEncontrada == null) { return ResponseEntity.notFound().build(); } if (factura.getDescripcion() != null) { facturaEncontrada.setDescripcion(factura.getDescripcion()); } if (factura.getObservacion() != null) { facturaEncontrada.setObservacion(factura.getObservacion()); } if (factura.getFechaCreacion() != null) { facturaEncontrada.setFechaCreacion(factura.getFechaCreacion()); } //si se requiere cambiar de cliente la factura if (factura.getCliente() != null) { Cliente cliente = clienteService.findById(factura.getCliente().getId()); if (cliente != null) { facturaEncontrada.setCliente(cliente); } } return ResponseEntity.status(HttpStatus.CREATED).body(facturaService.save(facturaEncontrada)); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity<?> create(@RequestBody Factura factura) { try { return ResponseEntity.status(HttpStatus.CREATED) .body(facturaService.save(factura)); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { try { facturaService.delete(id); return ResponseEntity.noContent().build(); } catch (Exception e) { return ResponseEntity.notFound().build(); } } } 11. Pruebas en Postman Crear Cliente: { \"nombre\":\"Marcelo\", \"apellido\":\"Galvis\", \"email\":\"marcelogalvis@gmail.com\" } Actualizar Cliente: { \"nombre\":\"Jose\", \"apellido\":\"Guevara\", \"email\":\"joseluisguevara@gmail.com\", \"fechaCreacion\":\"2021-01-01\" } Listar Cliente: Listar un Cliente: Crear Factura: { \"descripcion\":\"Factura 4\", \"observacion\":\"Factura Insumos de Oficina\", \"email\":\"jose@gmail.com\", \"fechaCreacion\":\"2021-01-01\", \"cliente\" :{ \"id\": 1, \"nombre\": \"Jose\", \"apellido\": \"Guevara\", \"email\": \"jose@gmail.com\", \"fechaCreacion\": \"2020-12-31\" } } Actualizar Factura: { \"descripcion\":\"Factura 5\", \"observacion\":\"Factura Insumos de Oficina\", \"email\":\"jose@gmail.com\", \"fechaCreacion\":\"2021-01-01\", \"cliente\" :{ \"id\": 3 } } Listar Facturas: Listar una Factura:","title":"Servicios Web REST sobre Spring Boot con Maven en NetBeans:"},{"location":"#servicios-web-rest-sobre-spring-boot-con-maven-en-netbeans","text":"","title":"Servicios Web REST sobre Spring Boot con Maven en NetBeans:"},{"location":"#1-configurar-el-plugin-de-spring-tools-en-netbeans","text":"Se ingresa a Tools --> Plugins Se abrir\u00e1 la ventana de Plugins, damos click en la pesta\u00f1a Available Plugins y Buscamos NB SpringBoot","title":"1. Configurar el Plugin de Spring Tools en NetBeans"},{"location":"#2-crear-el-proyecto","text":"Vamos a File New Project\u2026 Seleccionamos Java with Maven: Digitamos el Nombre de nuestro grupo de paquetes, el Artifact, el Empaquetado, la descripci\u00f3n, el lenguaje Java y la version: Agregamos las dependencias: Agregamos el nombre y ubicaci\u00f3n del proyecto:","title":"2. Crear el Proyecto"},{"location":"#3-crear-la-base-de-datos","text":"Ingresar a su manejador de base de datos y ejecutar el comando, para crear la base de datos: CREATE DATABASE webinarunab;","title":"3. Crear la base de datos"},{"location":"#4-cargar-configuracion-en-el-applicationproperties","text":"Una vez creado el proyecto, vamos al application.properties, donde vamos a indicar la cadena de conexi\u00f3n de MySQL, el puerto por el que va correr el API y los par\u00e1metros del hib\u00e9rnate, as\u00ed: server.port=9011 spring.datasource.url=jdbc:mysql://localhost:3306/webinarunab spring.datasource.username=root spring.datasource.password=******* ## Hibernate Properties # The SQL dialect makes Hibernate generate better SQL for the chosen database spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect # Hibernate ddl auto (create, create-drop, validate, update) spring.jpa.hibernate.ddl-auto = create Nota: Modificar los datos correspondientes seg\u00fan la configuraci\u00f3n de servidor de mysql, cambiando el nombre de la base de datos, si la crearon diferente, cambiando el username por su usuario y los asteriscos * por la password del usuario del MySQL.","title":"4. Cargar Configuraci\u00f3n en el application.properties"},{"location":"#5-crear-los-paquetes","text":"El siguiente paso es crear los paquetes debajo del paquete principal donde se encuentra la clase @SpringBootApplication, la estructura debe quedar de la siguiente manera: Para crear un paquete se debe dar click derecho sobre el paquete principal, luego New--> Java Package\u2026 Creamos el Paquete Models: Creamos el Paquete Repositories : Creamos el Paquete Services: Creamos el SubPaquete Impls: Este es el subpaquete que implementa las interfaces de nuestro paquete services, por lo cual se debe crear debajo de services, dando click derecho sobre service --> new --> Java Package\u2026 Creamos el Paquete Controllers:","title":"5. Crear Los Paquetes"},{"location":"#6-creamos-las-clases-de-models","text":"Paso 1: Estas clases ser\u00e1n nuestras Entity, por lo cual las debemos crear dando click derecho sobre el paquete Models, new --> Java Class\u2026 Digitamos el nombre de la clase: Paso 2: Una vez creada la Clase Le Agregamos la Anotaci\u00f3n @Entity, adicionalmente es una buena practica que las clases del Models implementen la interface Serealizable, eso lo agregamos en la declaraci\u00f3n de la clase con implements Serializable: Nota: Importante cuando estemos agregando las anotaciones importar las respectivas clases necesarias, las de persistencia se importan de javax.persistence.Table: Si estamos trabajando con un IDE o un editor de c\u00f3digo con un buen plugin, cuando agreguemos las anotaciones @Entity y @Table, nos va a proponer que implementemos el comportamiento de la interfaz se realizable: Paso 3: Luego declaramos los campos de la entidad y debe quedar as\u00ed: Crear Clase Factura: Repetimos los pasos 1, 2 y 3 del punto 6, para que nos quede una clase Factura As\u00ed: Una vez tenemos las clases de esta manera vamos a dar un vistazo al modelo entidad relaci\u00f3n donde se especifican las relaciones, este es un ejercicio b\u00e1sico con 3 tablas de las cuales vamos a desarrollar dos: Nota: los ides fueron modificados para simular en el programa de dise\u00f1o el nombre con que SpringBoot Crea las relaciones for\u00e1neas, pero en la clase el id de cada entidad, ser\u00e1 nombrado como \u201cid\u201d autoincrementadle. En este punto vamos a editar el archivo POM.xml para agregar una dependencia de validaci\u00f3n: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> Revisamos las condiciones de la entidad Cliente: Con este planteamiento debemos agregar las respectivas anotaciones a cada campo seg\u00fan los detalles de cada uno: Al id le agregamos la anotaci\u00f3n @Id para identificarla como llave primaria de la entidad y el @GeneratedValue(strategy = GenerationType.IDENTITY) para que este sea autoincrementable. Al nombre le agregamos la anotaci\u00f3n @NotEmpty(message = \"no puede estar vacio\") con un mensaje, indicando que este no puede ser vacio, el @Size(min = 4, max = 12, message = \"el tama\u00f1o tiene que estar entre 4 y 12\") para especificar el tama\u00f1o m\u00ednimo y m\u00e1ximo del nombre, con el respectivo mensaje informativo y el @Column(nullable = false, length=30)) indicado que este campo es NOT NULL y largo de 30. Al apellido le agregamos @NotEmpty(message = \"no puede estar vacio\") y @Column(nullable = false, length=30). Al mail le agregamos @NotEmpty(message = \"no puede estar vacio\"), la validacion @Email(message = \"no es una direcci\u00f3n de correo bien formada\") y @Column(nullable = false, unique = true) NOT NULL y que no se pueda repetir. A la fechaCreacion le agregamos el @Column(name = \"fecha_creacion\") le ponemos un nombre y @Temporal(TemporalType.DATE) para que lo interprete como tipo DATE. En aras de optimizar el API, vamos a agregar una vinculaci\u00f3n de la relaci\u00f3n de uno a muchos que tiene con la Entidad Factura, esto con el objetivo de que en el momento de hacer un llamado al cliente, no regrese las facturas que tiene dicho cliente, para eso vamos a crear otro campo de tipo Lista que retorna facturas; List y le vamos agregar las anotaciones @JsonIgnoreProperties(value={\"cliente\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) para que hibernate no lo cree como campo de la tabla, @OneToMany(fetch = FetchType.LAZY, mappedBy = \"cliente\", cascade = CascadeType.ALL) indicando la relaci\u00f3n de uno a muchos la cual se ejecutara en modo Lazy, para que se cargue cuando se necesiten, mapeado por el cliente, que es el campo declarado en la tabla factura como llave for\u00e1nea y la propiedad cascade, para que respete la jerarqu\u00eda seg\u00fan las relaciones de la tabla, es decir si deseamos borrar un cliente, en cascada se borraran las facturas. Luego insertamos el constructor, \u00fanicamente carg\u00e1ndole el campo facturas que son las que ser\u00e1n variables: Paso 1: Click derecho Insert Code\u2026 Paso 2: Click en Constructor: Paso 3: Click en facturas y luego Generate: Despu\u00e9s, click derecho insert code --> Getter and Setter y seleccionamos todo: Finalmente agregaremos un m\u00e9todo con la anotaci\u00f3n @PrePersist para asignar la fecha de creaci\u00f3n de cliente antes de guardar, es un m\u00e9todo de preguardado. @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } La Clase Cliente, queda as\u00ed: import com.fasterxml.jackson.annotation.JsonIgnoreProperties; import java.io.Serializable; import java.util.ArrayList; import java.util.Date; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToMany; import javax.persistence.PrePersist; import javax.persistence.Table; import javax.persistence.Temporal; import javax.persistence.TemporalType; import javax.validation.constraints.Email; import javax.validation.constraints.NotEmpty; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; @Entity @Table(name = \"cliente\") public class Cliente implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty(message = \"no puede estar vacio\") @Size(min = 4, max = 12, message = \"el tama\u00f1o tiene que estar entre 4 y 12\") @Column(nullable = false, length = 30) private String nombre; @NotEmpty(message = \"no puede estar vacio\") @Column(nullable = false, length = 30) private String apellido; @NotEmpty(message = \"no puede estar vacio\") @Email(message = \"no es una direcci\u00f3n de correo bien formada\") @Column(nullable = false, unique = true) private String email; //@NotNull(message = \"no puede estar vacio\") @Column(name = \"fecha_creacion\") @Temporal(TemporalType.DATE) private Date fechaCreacion; @JsonIgnoreProperties(value = {\"cliente\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters = true) @OneToMany(fetch = FetchType.LAZY, mappedBy = \"cliente\", cascade = CascadeType.ALL) private List<Factura> facturas; @PrePersist public void prePersist() { System.out.println(\"Preguardado\"); this.fechaCreacion = new Date(); } public Cliente() { this.facturas = new ArrayList<>(); } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getFechaCreacion() { return fechaCreacion; } public void setFechaCreacion(Date fechaCreacion) { this.fechaCreacion = fechaCreacion; } public List<Factura> getFacturas() { return facturas; } public void setFacturas(List<Factura> facturas) { this.facturas = facturas; } } Revisamos las condiciones de la entidad Factura: Con este planteamiento debemos agregar las respectivas anotaciones a cada campo seg\u00fan los detalles de cada uno: Al Id @Id y @GeneratedValue(strategy = GenerationType.IDENTITY), llave primaria y autoincrementadle. A la descripci\u00f3n @Column(nullable = false, length=200). A la observaci\u00f3n @Column(nullable = false, length=500) A la fechaCreacion el @Column(name = \"fecha_creacion\") y @Temporal(TemporalType.DATE) Al cliente @JsonIgnoreProperties(value={\"factura\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) y @ManyToOne(fetch = FetchType.LAZY) el JsonIgnore y la relaci\u00f3n de mucho a uno, aqu\u00ed no es necesario especificarle el nombre del campo en la tabla, por que por defecto SpringBoot lo crea siguiendo, la l\u00f3gica del nombre de la clase seguido de raya al piso id as\u00ed: cliente_id. Finalmente agregaremos un m\u00e9todo con la anotaci\u00f3n @PrePersist para asignar la fecha de creaci\u00f3n de cliente antes de guardar, es un m\u00e9todo de preguardado. @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } Agregamos Los Getter y Setter, luego la Clase Factura Quedar\u00eda As\u00ed: @Entity @Table(name=\"factura\") public class Factura implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length=200) private String descripcion; @Column(nullable = false, length=500) private String observacion; @Column(name = \"fecha\\_creacion\") @Temporal(TemporalType.DATE) private Date fechaCreacion; @JsonIgnoreProperties(value={\"factura\", \"hibernateLazyInitializer\", \"handler\"}, allowSetters=true) @ManyToOne(fetch = FetchType.LAZY) private Cliente cliente; @PrePersist public void prePersist() { this.fechaCreacion = new Date(); } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getObservacion() { return observacion; } public void setObservacion(String observacion) { this.observacion = observacion; } public Date getFechaCreacion() { return fechaCreacion; } public void setFechaCreacion(Date fechaCreacion) { this.fechaCreacion = fechaCreacion; } public Cliente getCliente() { return cliente; } public void setCliente(Cliente cliente) { this.cliente = cliente; } }","title":"6. Creamos Las Clases de Models"},{"location":"#7-creamos-las-interfaces-del-repositories","text":"Si estamos utilizando un buen plugin este proceso es sencillo, si lo que queremos es utilizar el repositorio solo para un crud, siguiendo los siguientes pasos, de igual manera si lo vamos hacer a mano creando la interface y heredando de la clase CrudRepository o JpaRepository seg\u00fan lo que se desee, la diferencia entre los dos es que Jpa incluye mas anotaciones para personalizar nuestro repositorio. Vamos a dar click derecho sobre el paquete respositories --> New --> Repository Interface Digitamos el nombre ClienteRepository, La interface base, le Entidad y el Tipo de dato del Id de la Clase Entidad: Nota: si no encontramos entre los primeros se debe buscar en Other as\u00ed, en la categor\u00eda Spring Framework estan las Clases e Interfaces, que podr\u00e1n creadas con un ayuda del plugin: Quedar\u00e1 as\u00ed: Una vez Creada debemos importar la clase entidad, para corregir el error que vemos en la imagen. La clase ClienteRepository quedar\u00eda as\u00ed: package com.example.webinaUnab.repositories; import com.example.webinaUnab.models.Cliente; import org.springframework.data.jpa.repository.JpaRepository; /** * * @author Marlon */ public interface ClienteRepository extends JpaRepository<Cliente, Long> { } Repetimos el proceso para agregar la clase FacturaRepository: ![](Aspose.Words.1885f979-9e30-4ff3-91e0-fd4ffca79d3f.032.png) la cual quedar\u00eda as\u00ed: package com.example.webinaUnab.repositories; import com.example.webinaUnab.models.Factura; import org.springframework.data.jpa.repository.JpaRepository; /\\\\** \\** \\ @author Marlon \\/ public interface FacturaRepository extends JpaRepository<Factura, Long> { \\ }","title":"7. Creamos Las Interfaces del Repositories:"},{"location":"#8-creamos-las-interfaces-de-los-services","text":"Se crea una nueva interface, pero ojo es importante que este se cree sobe el paquete service, teniendo en cuenta que al crear el paquete service y el subpaquete impls, queda todo el subpaquete asi: Con lo cual en el momento de crear la interface se debe modificar dejando claro que esa interface se va crear sobre el paquete services, especificando el siguiente par\u00e1metro en el package: com.example.webinaUnab.services. Adicionalmente es una buena practica al momento de nombrarlo agregarle la inicial \u201cI\u201d que la identifica como Interface, luego el nombre de la Entidad y El apellido serie el Paquete Service quedando IClienteService y IFacturaService: Creamos la interface y agregamos las funciones y m\u00e9todos: findAll retorna una lista de objetos Cliente: public List findAll(); findAll retorna un objeto Page con Cliente: public Page findAll(Pageable pageable); findById recibe como par\u00e1metro el id y retorna un Cliente: public Cliente findById(Long id); save, recibe un Cliente y retorna un Cliente: public Cliente save(Cliente cliente); delete, recibe el id para borrar el Cliente: public void delete(Long id); Esos son los m\u00e9todos b\u00e1sicos para hacer un CRUD, la interface IClienteService quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import java.util.List; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; /** * * @author Marlon */ public interface IClienteService { public List<Cliente> findAll(); public Page<Cliente> findAll(Pageable pageable); public Cliente findById(Long id); public Cliente save(Cliente cliente); public void delete(Long id); } Repetimos los mismos pasos para crear todas las interfaces, para continuar con lo que venimos desarrollando, la Interface IFacturaService quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Factura; import java.util.List; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; /** * * @author Marlon */ public interface IFacturaService { public List<Factura> findAll(); public Page<Factura> findAll(Pageable pageable); public Factura findById(Long id); public Factura save(Factura factura); public void delete(Long id); }","title":"8. Creamos las Interfaces de los Services"},{"location":"#9-implementamos-las-interfaces-de-los-services","text":"El plugin de NetBeans tambi\u00e9n nos ayuda en la creaci\u00f3n de una clase service, pero si se decide hacer a mano es solo crear una nueva clase y agregarle la anotaci\u00f3n @service: Paso 1: Crear La Clase Asignamos el nombre ClienteServiceImpl y click en Finish: Paso 2: Declaramos que esta interface implementa los metodos de IClienteService con: implements IClienteService Luego importamos IClienteService y nos pedir\u00e1 que implementemos los m\u00e9todos de la interface: Paso 3: Una vez se implementan los m\u00e9todos estos se crean con una interrupci\u00f3n como c\u00f3digo, la cual debemos borrar y codificar las verdaderas funciones de cada m\u00e9todo: Paso 4: Pero antes de esto vamos a inyectar con la anotaci\u00f3n @Autowired una variable te tipo del Repositorio correspondiente a Cliente, la cual es ClienteRepository @Autowired private ClienteRepository clienteRepository; Paso 5: En este paso vamos a codificar los m\u00e9todos, sobre el nombre de cada m\u00e9todo vamos agregar la anotaci\u00f3n @Transactional(readOnly = true) para identificar que es un m\u00e9todo de tipo transaccional, luego quitamos la interrupci\u00f3n throw. Es importante cuando importemos la clase revisar que lo importemos de springbootframework para evitar errore: Funci\u00f3n findAll: esta funci\u00f3n retorna una lista de tipo Cliente, la cual la obtenemos invocando el m\u00e9todo findAll heredado de JpaRepository para la Entidad Cliente, usando la variable del repositorio clienteRepository.findAll(), el return quedar\u00eda as\u00ed: return (List ) clienteRepository.findAll(); Funci\u00f3n findAll(Pageable pageable): esta funci\u00f3n retorna una lista paginada de clientes, la cual obtenemos llamando el m\u00e9todo findAll(Pageable pageable) que recibe un objeto pageable, el return quedar\u00eda as\u00ed: return clienteRepository.findAll(pageable); Funci\u00f3n findById: esta funci\u00f3n recibe el id de un Cliente los busca y lo retorna, con lo cual el return se hace mediante el m\u00e9todo findById(id) que recibe un id y con la ayuda del submetodo orElse(null) retorna null si no lo encuentra, el return quedar\u00eda as\u00ed: return clienteRepository.findById(id).orElse(null); Funci\u00f3n save: esta funci\u00f3n recibe un objeto de tipo Cliente y con la ayuda del clienteRepository, invoca el m\u00e9todo save(cliente) que recibe el objeto Cliente y lo guarda en la tabla cliente, luego lo retorna, el c\u00f3digo quedar\u00eda as\u00ed: return clienteRepository.save(cliente); Metodo delete: este m\u00e9todo recibe un id de tipo long y mediante el clienteRepository, invoca el m\u00e9todo delete(id) que esta dise\u00f1ado por JpaRepository para eliminar un objeto de la tabla cliente cuando este coincida con el id recibido, el c\u00f3digo quedar\u00eda asi: clienteRepository.deleteById(id); La Clase ClienteServiceImpl quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import com.example.webinaUnab.repositories.ClienteRepository; import com.example.webinaUnab.services.IClienteService; import java.awt.print.Pageable; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; /** * * @author Marlon */ @Service public class ClienteServiceImpl implements IClienteService { @Autowired private ClienteRepository clienteRepository; @Override @Transactional(readOnly = true) public List<Cliente> findAll() { return (List<Cliente>) clienteRepository.findAll(); } @Override @Transactional(readOnly = true) public Page<Cliente> findAll(org.springframework.data.domain.Pageable pageable) { return clienteRepository.findAll(pageable); } @Override @Transactional(readOnly = true) public Cliente findById(Long id) { return clienteRepository.findById(id).orElse(null); } @Override public Cliente save(Cliente cliente) { return clienteRepository.save(cliente); } @Override public void delete(Long id) { clienteRepository.deleteById(id); } } Repetimos los paso 1, 2, 3, 4 y 5 con las dem\u00e1s servicios y los implementamos seg\u00fan las interfaces creadas, para seguir con el proyecto como lo llevamos la clase FacturaServiceImpl quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Factura; import com.example.webinaUnab.repositories.FacturaRepository; import com.example.webinaUnab.services.IFacturaService; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; /** * * @author Marlon */ @Service public class FacuraServiceImpl implements IFacturaService { @Autowired private FacturaRepository facturaRepository; @Override @Transactional(readOnly = true) public List<Factura> findAll() { return (List<Factura>) facturaRepository.findAll(); } @Override @Transactional(readOnly = true) public Page<Factura> findAll(Pageable pageable) { return facturaRepository.findAll(pageable); } @Override @Transactional(readOnly = true) public Factura findById(Long id) { return facturaRepository.findById(id).orElse(null); } @Override public Factura save(Factura factura) { return facturaRepository.save(factura); } @Override public void delete(Long id) { facturaRepository.deleteById(id); } }","title":"9. Implementamos las Interfaces de los Services"},{"location":"#10-crear-los-controllers","text":"El ultimo paso para verificar el funcionamiento de nuestra API, donde se van a configurar las rutas URI y los M\u00e9todos Utilizados en el APIREST se deben crear los controladores uno por cada servicio implementado, el plugin de NetBeans nos ayuda a crearlos, pero tambi\u00e9n se puede crear a mano agregando la anotaci\u00f3n @RestController. Paso 1: Damos Click derecho sobre el paquete controllers-->new-->RestController Class\u2026 El plugin nos ayuda a crear los m\u00e9todos para el CRUD y validar los errores HTTP, si deseamos que sean generados autom\u00e1ticamente debemos chequear Generate CRUD methods: Esto crea autom\u00e1ticamente un controlador con rutas URI por defecto y c\u00f3digos M\u00e9todos que retornan ResponseEntity para el manejo de c\u00f3digos de estado HTTP, en los m\u00e9todos del CRUD, adicionalmente nos genera los m\u00e9todos de comunicaci\u00f3n de la API, GET, PUT, POST, DELETE: Paso 2: Procedemos a editar la URI y a codificar cada uno de los m\u00e9todos los cuales por defecto cuando se crean autom\u00e1ticamente retornan null, es decir hay que codificarle los m\u00e9todos de los servicios. Una vez editemos el m\u00e9todo del encabezado vamos a agregar la anotaci\u00f3n @CrossOrigin(origins = { \"http://localhost:4200\", \"*\" }) donde podemos indicarle desde que URL se va consumir la API, en este ejemplo agregamos localhost:4200 y \\ este ultimo permite peticiones de cualquiera, esto es lo que se conoce como validaci\u00f3n de CORS(Intercambio de Or\u00edgenes Cruzado). Cross-origin resource sharing es lo que nos da el acceso a los recursos esta anotaci\u00f3n puede ser personalizada por cada m\u00e9todo o se puede agregar a todo el controlador. Paso 3: Procedemos a inyectar la variable del servicio con la anotaci\u00f3n @Autowired, podemos inyectar la interface, java toma por defecto la clase que implementa los m\u00e9todos de la interface, quedando as\u00ed: @Autowired private IClienteService clienteService; Paso 4: Codificar Funciones y M\u00e9todos del Controlador. Funci\u00f3n list: Retorna una lista de objetos Cliente, la codificaci\u00f3n quedar\u00eda as\u00ed, invocando el medido findAll() del servicio: @GetMapping() public List<Cliente> list() { **return clienteService.findAll();** } Funci\u00f3n index: Esta funci\u00f3n retorna un objeto Page de tipo cliente, que recibe un valor integer con el numero de pagina que se desea retornar, el c\u00f3digo quedar\u00eda as\u00ed: @GetMapping(\"/clientes/page/{page}\") public Page<Cliente> index(@PathVariable Integer page) { Pageable pageable = PageRequest.of(page,4); return clienteService.findAll(pageable); } Funci\u00f3n get: Esta funci\u00f3n recibe un par\u00e1metro id y retorna un Objeto Cliente en formato Json, con lo cual para personalizar la respuesta en caso que no exista, se creo adem\u00e1s del objeto Cliente, un Mapa que contiene una respuesta, con un mensaje de error, esta funcion tambien retorna adem\u00e1s de la respuesta un c\u00f3digo de estado HTTP, quedando as\u00ed: @GetMapping(\"/{id}\") public ResponseEntity<?> get(@PathVariable Long id) { Cliente cliente = null; Map<String, Object> response = new HashMap<>(); try { cliente = clienteService.findById(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar la consulta en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } if (cliente == null) { response.put(\"mensaje\", \"El cliente ID: \".concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT\\_FOUND); } return new ResponseEntity<Cliente>(cliente, HttpStatus.OK); } Funci\u00f3n put: esta funci\u00f3n retorna un c\u00f3digo de estado HTTP, esta validado con la anotaci\u00f3n @Valid y recibe del @RequestBody un cliente con los nuevos datos, BindingResult result para la validaci\u00f3n de la dependencia validator y @PathVariable Long id con el identificador del cliente que se va actualizar. Lo siguiente es buscar el cliente que se va actualizar: Cliente clienteActual = clienteService.findById(id); Declaramos una variable de tipo Cliente donde se va cargar los datos del cliente actualizado: Cliente clienteUpdated = null; Declaramos un mapa para manejar la respuesta: Map response = new HashMap<>(); Si el validador saca error responderemos con los parametros de respuesta que le agregamos a la validaci\u00f3n, los cuales cargamos en una lista de tipo String de nombre errors, cargamos la lista al mapa response.put(\u201cerrors\u201d, errors) y retornamos el mapa con el c\u00f3digo HTTP Bad Request: if (result.hasErrors()) List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); Luego si el cliente es nulo retornamos el mapa con un mensaje indicando que no existe en la base de datos: response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD\\_REQUEST); } Si todo esta correcto actualizamos el cliente, carg\u00e1ndolo al mapa y lo retornamos como respuesta con el c\u00f3digo Created: try { clienteActual.setApellido(cliente.getApellido()); clienteActual.setNombre(cliente.getNombre()); clienteActual.setEmail(cliente.getEmail()); clienteActual.setFechaCreacion(cliente.getFechaCreacion()); clienteUpdated = clienteService.save(clienteActual); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al actualizar el cliente en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente ha sido actualizado con \u00e9xito!\"); response.put(\"cliente\", clienteUpdated); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); Funci\u00f3n create: Este m\u00e9todo esta validado con el @Valid y recibe mediante el @RequestBody un objeto Cliente cliente y BindingResult result para validar. Declaramos la variable Cliente que vamos a retornar: Cliente clienteNew = null; Declaramos tambi\u00e9n el mapa para la respuesta personalizada: Map response = new HashMap<>(); Validamos si hay errores, los capturamos en una lista y los cargamos al mapa para responder con un c\u00f3digo Bad Request: if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD\\_REQUEST); } Si todo es correcto ejecutamos el m\u00e9todo sabe, si por alg\u00fan motivo el m\u00e9todo sabe falla, se captura la excepci\u00f3n y se retorna un HTTP de error interno del servidor, si no hay excepciones se carga el mapa de respuesta que incluye el objeto cliente que esta en la variable clienteNew: try { clienteNew = clienteService.save(cliente); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar el insert en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente ha sido creado con \u00e9xito!\"); response.put(\"cliente\", clienteNew); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); Funci\u00f3n Delete: esta funci\u00f3n recibe como par\u00e1metro el id del cliente, el cual se va enviar en el delete, tambi\u00e9n declaramos un mapa para la respuesta: Map<String, Object> response = new HashMap<>(); try { clienteService.delete(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al eliminar el cliente de la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL\\_SERVER\\_ERROR); } response.put(\"mensaje\", \"El cliente eliminado con \u00e9xito!\"); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); El c\u00f3digo completo del controlador ClienteController quedar\u00eda as\u00ed: import com.example.webinaUnab.models.Cliente; import com.example.webinaUnab.services.IClienteService; import java.util.HashMap; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; import java.util.Map; import java.util.stream.Collectors; import javax.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.dao.DataAccessException; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.http.HttpStatus; import org.springframework.validation.BindingResult; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseStatus; /** * * @author Marlon */ @CrossOrigin(origins = {\"http://localhost:4200\", \"*\"}) @RestController @RequestMapping(\"/cliente\") public class ClienteRestController { @Autowired private IClienteService clienteService; @GetMapping() public List<Cliente> list() { return clienteService.findAll(); } @GetMapping(\"/clientes/page/{page}\") @ResponseStatus(HttpStatus.OK) public Page<Cliente> index(@PathVariable Integer page) { Pageable pageable = PageRequest.of(page, 4); return clienteService.findAll(pageable); } @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public ResponseEntity<?> get(@PathVariable Long id) { Cliente cliente = null; Map<String, Object> response = new HashMap<>(); try { cliente = clienteService.findById(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar la consulta en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } if (cliente == null) { response.put(\"mensaje\", \"El cliente ID: \".concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); } return new ResponseEntity<Cliente>(cliente, HttpStatus.OK); } @PutMapping(\"/{id}\") public ResponseEntity<?> put(@Valid @RequestBody Cliente cliente, BindingResult result, @PathVariable Long id) { Cliente clienteActual = clienteService.findById(id); Cliente clienteUpdated = null; Map<String, Object> response = new HashMap<>(); if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST); } if (clienteActual == null) { response.put(\"mensaje\", \"Error: no se pudo editar, el cliente ID: \" .concat(id.toString().concat(\" no existe en la base de datos!\"))); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); } try { clienteActual.setApellido(cliente.getApellido()); clienteActual.setNombre(cliente.getNombre()); clienteActual.setEmail(cliente.getEmail()); clienteActual.setFechaCreacion(cliente.getFechaCreacion()); clienteUpdated = clienteService.save(clienteActual); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al actualizar el cliente en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente ha sido actualizado con \u00e9xito!\"); response.put(\"cliente\", clienteUpdated); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); } @PostMapping public ResponseEntity<?> create(@Valid @RequestBody Cliente cliente, BindingResult result) { Cliente clienteNew = null; Map<String, Object> response = new HashMap<>(); System.out.println(cliente.getApellido()); if (result.hasErrors()) { List<String> errors = result.getFieldErrors() .stream() .map(err -> \"El campo '\" + err.getField() + \"' \" + err.getDefaultMessage()) .collect(Collectors.toList()); response.put(\"errors\", errors); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST); } try { clienteNew = clienteService.save(cliente); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al realizar el insert en la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente ha sido creado con \u00e9xito!\"); response.put(\"cliente\", clienteNew); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); } @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { Map<String, Object> response = new HashMap<>(); try { //Cliente cliente = clienteService.findById(id); clienteService.delete(id); } catch (DataAccessException e) { response.put(\"mensaje\", \"Error al eliminar el cliente de la base de datos\"); response.put(\"error\", e.getMessage().concat(\": \").concat(e.getMostSpecificCause().getMessage())); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); } response.put(\"mensaje\", \"El cliente eliminado con \u00e9xito!\"); return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); } } Repetimos el paso 1,2,3 y 4 para crear el controlador de la entidad Factura, FacturaController, en el controlador anterior creamos un controlador completo con respuesta personalizada, lo cual hace que nuestra API, nos entregue respuestas mas claras, pero si quisi\u00e9ramos hacer un CRUD muy b\u00e1sico podemos hacerlo sin la necesidad de validar, esto no es recomendable porque nos exponemos a muchos errores que no entenderemos en el FrontEnd, pero para este ejercicio acad\u00e9mico vamos a crear este segundo controlador b\u00e1sico sin validaciones. Repetimos el paso 1, creamos el Rest Controller, le asignamos el nombre y chequemos el Generate CRUD methods: No genera la estructura b\u00e1sica de los m\u00e9todos la cual vamos a modificar seg\u00fan la necesidad: Lo primero es agregar con @Autowired la variable del servicio que vamos a inyectar directamente al controlador. @Autowired private IFacturaService facturaService; Funci\u00f3n List: este m\u00e9todo lista todas las facturas registradas, le agregamos la anotaci\u00f3n @ResponseStatus(HttpStatus.OK) para que por defecto responda c\u00f3digo 200 y con return facturaService.findAll(); liste las facturas, el metodo completo quedar\u00eda asi: @GetMapping() @ResponseStatus(HttpStatus.OK) public List<Factura> list() { return facturaService.findAll(); } Funci\u00f3n get: esta recibe el id de la factura y retorna una factura, tambi\u00e9n agregamos la anotaci\u00f3n @ResponseStatus(HttpStatus.OK) y con facturaService.findById(id) retornamos la factura buscada, es importante cuando se crean autom\u00e1ticamente los m\u00e9todos del controlador, reemplazar el Object que le agrega por defecto a los m\u00e9todos por la clase correspondiente en este caso seria Factura, la funci\u00f3n completa queda as\u00ed: @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public Factura get(@PathVariable Long id) { return facturaService.findById(id); } Funci\u00f3n create: esta es la que se encarga de crear la factura en la base de datos, recibe un objeto de tipo factura la cual vamos a guardar, para agregar una validaci\u00f3n b\u00e1sica agregamos un try catch, en el try ejecutamos la funci\u00f3n save y retornamos la factura con c\u00f3digo HTTP 200, en caso de alg\u00fan error pasar\u00eda por la excepci\u00f3n que retorna un error NotFound. @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity<?> create(@RequestBody Factura factura) { try{ return ResponseEntity.status(HttpStatus.CREATED) .body(facturaService.save(factura)); } catch (Exception e) { return ResponseEntity.notFound().build(); } Funci\u00f3n delete: Esta funci\u00f3n recibe el id de la factura y con la funci\u00f3n delete la borra de la base de datos, igual que en el save vamos agregar un try para controlar los errores en caso que el m\u00e9todo delete falle nos responda NotFoun, en caso que elimine la factura responder\u00eda el c\u00f3digo 204, el m\u00e9todo completo quedar\u00eda as\u00ed: @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { try { facturaService.delete(id); return ResponseEntity.noContent().build(); } catch (Exception e) { return ResponseEntity.notFound().build(); } } Funci\u00f3n put: este es el m\u00e9todo mediante el cual vamos actualizar los datos de la factura incluso si se desea cambiar el cliente, recibimos mediante el @RequesBody la factura con los datos en Json y por el @PathVariable el id de la factura que se va a modificar, lo siguiente que se hace es buscar la factura, porque si el id que nos pasan no existe, no se podr\u00e1 hacer la actualizaci\u00f3n, si no existe el API responde Not Found, pero si existe validamos que vengan los campos necesarios para actualizar, en la parte del cliente ocurre algo importante, si viene el objeto cliente dentro del json del cual podremos actualizar el id, buscamos el cliente y lo actualizamos. @PutMapping(\"/{id}\") public ResponseEntity<?> put(@RequestBody Factura factura, @PathVariable(value = \"id\") Long id) { Factura facturaEncontrada = facturaService.findById(id); if (facturaEncontrada == null) { return ResponseEntity.notFound().build(); } if (factura.getDescripcion() != null) { facturaEncontrada.setDescripcion(factura.getDescripcion()); } if (factura.getObservacion() != null) { facturaEncontrada.setObservacion(factura.getObservacion()); } if (factura.getFechaCreacion() != null) { facturaEncontrada.setFechaCreacion(factura.getFechaCreacion()); } //si se requiere cambiar de cliente la factura if (factura.getCliente() != null) { Cliente cliente = clienteService.findById(factura.getCliente().getId()); if (cliente != null) { facturaEncontrada.setCliente(cliente); } } return ResponseEntity.status(HttpStatus.CREATED).body(facturaService.save(facturaEncontrada)); } El Controlador FacturaController completo queda as\u00ed: /** * * @author Marlon */ @RestController @CrossOrigin(origins = \"/*\") @RequestMapping(\"/factura\") public class FacturaRestController { @Autowired private IFacturaService facturaService; @Autowired private IClienteService clienteService; @GetMapping() @ResponseStatus(HttpStatus.OK) public List<Factura> list() { return facturaService.findAll(); } @GetMapping(\"/{id}\") @ResponseStatus(HttpStatus.OK) public Factura get(@PathVariable Long id) { return facturaService.findById(id); } //actualizar @PutMapping(\"/{id}\") public ResponseEntity<?> put(@RequestBody Factura factura, @PathVariable(value = \"id\") Long id) { Factura facturaEncontrada = facturaService.findById(id); if (facturaEncontrada == null) { return ResponseEntity.notFound().build(); } if (factura.getDescripcion() != null) { facturaEncontrada.setDescripcion(factura.getDescripcion()); } if (factura.getObservacion() != null) { facturaEncontrada.setObservacion(factura.getObservacion()); } if (factura.getFechaCreacion() != null) { facturaEncontrada.setFechaCreacion(factura.getFechaCreacion()); } //si se requiere cambiar de cliente la factura if (factura.getCliente() != null) { Cliente cliente = clienteService.findById(factura.getCliente().getId()); if (cliente != null) { facturaEncontrada.setCliente(cliente); } } return ResponseEntity.status(HttpStatus.CREATED).body(facturaService.save(facturaEncontrada)); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity<?> create(@RequestBody Factura factura) { try { return ResponseEntity.status(HttpStatus.CREATED) .body(facturaService.save(factura)); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @DeleteMapping(\"/{id}\") public ResponseEntity<?> delete(@PathVariable Long id) { try { facturaService.delete(id); return ResponseEntity.noContent().build(); } catch (Exception e) { return ResponseEntity.notFound().build(); } } }","title":"10.  Crear los Controllers"},{"location":"#11-pruebas-en-postman","text":"Crear Cliente: { \"nombre\":\"Marcelo\", \"apellido\":\"Galvis\", \"email\":\"marcelogalvis@gmail.com\" } Actualizar Cliente: { \"nombre\":\"Jose\", \"apellido\":\"Guevara\", \"email\":\"joseluisguevara@gmail.com\", \"fechaCreacion\":\"2021-01-01\" } Listar Cliente: Listar un Cliente: Crear Factura: { \"descripcion\":\"Factura 4\", \"observacion\":\"Factura Insumos de Oficina\", \"email\":\"jose@gmail.com\", \"fechaCreacion\":\"2021-01-01\", \"cliente\" :{ \"id\": 1, \"nombre\": \"Jose\", \"apellido\": \"Guevara\", \"email\": \"jose@gmail.com\", \"fechaCreacion\": \"2020-12-31\" } } Actualizar Factura: { \"descripcion\":\"Factura 5\", \"observacion\":\"Factura Insumos de Oficina\", \"email\":\"jose@gmail.com\", \"fechaCreacion\":\"2021-01-01\", \"cliente\" :{ \"id\": 3 } } Listar Facturas: Listar una Factura:","title":"11. Pruebas en Postman"}]}